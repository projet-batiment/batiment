package fr.insa.dorgli.projetbat;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.function.Predicate;

// Un ArrayList qui fait aussi itérateur intelligent:
// - récupérer les élements next, previous, actuel, relatif...
// - loopAround: revient de l'autre côté quand on arrive au bord (TODO feature: dés/activer ?)
// - ajouter et suppression d'éléments en gardant le même idx (sauf pour quand c'est trop compliqué voir plus bas)
public class SmartIterator<T> extends ArrayList<T> implements Iterator {
	// Java c'est un langage génial:
	// C'est le genre qui te donne une classe List et une interface ListIterator
	// mais qui sont 100% incompatibles car la librairie "standard" n'est pas d'accord sur ses standards, justement !!!!!
	// Donc tant pis, on n'aura pas de ListIterator ici !!!!
	int idx;
	int loopedAround;
//	boolean loopAround; // TODO

	private void init(int idx) {
		setIdx(idx, true); // update with nofail
		this.loopedAround = 0;
	}
	private void init() {
		init(0);
	}

	public SmartIterator(Collection<? extends T> collection, int idx) {
		super(collection);
		init(idx);
	}
	public SmartIterator(Collection<? extends T> collection) {
		this(collection, 0);
	}

	public SmartIterator(int initialCapacity, int idx) {
		super(initialCapacity);
		init(idx);
	}

	// constructors with only initialCapacity and idx are skipped because of similar signature (int)
	public SmartIterator() {
		super();
		init();
	}

	// private because of loopedAround
	private SmartIterator(Collection<? extends T> collection, int idx, int loopedAround) {
		super(collection);
		init(idx);
		this.loopedAround = loopedAround;
	}

	///// idx position

	// this iterator loops around 
	@Override
	public boolean hasNext() {
		return true;
	}
	public boolean hasPrevious() {
		return true;
	}
	public boolean isLast() {
		return idx == super.size() - 1;
	}
	public boolean isFirst() {
		return idx == 0;
	}

	///// get elements

	public T relativeNoJump(int relativeNumber) {
		int realGetIdx = (idx + relativeNumber);
		loopedAround += (int)(realGetIdx / super.size());
		return (T)super.get(realGetIdx % super.size());
	}

	public T getCurrent() {
		return relativeNoJump(0);
	}

	public T relative(int relativeNumber) {
		idx += relativeNumber;
		loopedAround += (int)(idx / super.size());
		idx %= super.size();
		return getCurrent();
	}
	public T next() {
		return relative(1);
	}
	public T previous() {
		return relative(-1);
	}

	///// ArrayList implementation and redefinition

	/// utils
	private boolean updateIdx(boolean status, int diff) {
		if (status)
			setIdx(idx + diff, true); // update with nofail
		return status;
	}
	private boolean updateIdxAdd(boolean status, int diff, int whereIdx) {
		if (status && 0 <= whereIdx && whereIdx <= idx)
			setIdx(idx + diff, true); // update with nofail
		return status;
	}
	private boolean updateIdxRemove(boolean status, int diff, int whereIdx) {
		if (status && 0 <= whereIdx && whereIdx < idx)
			setIdx(idx + diff, true); // update with nofail
		return status;
	}

	/// actual implementations
	@Override
	public Object clone() {
		return new SmartIterator((Collection)super.clone(), idx, loopedAround);
	}

	@Override
	public void add(int addIdx, T elm) {
		updateIdxAdd(true, +1, addIdx);
		super.add(addIdx, elm);
	}
	@Override
	public void addFirst(T elm) {
		// always updateIdx !
		updateIdx(true, +1);
		super.addLast(elm);
	}
	@Override
	public void addLast(T elm) {
		// no updateIdx !
		super.addLast(elm);
	}

	@Override
	public T remove(int removeIdx) {
		updateIdxRemove(true, -1, removeIdx);
		return (T)super.remove(removeIdx);
	}
	@Override
	public T removeFirst() {
		updateIdxRemove(true, -1, 0);
		return (T)super.removeFirst();
	}
	@Override
	public T removeLast() {
		updateIdxRemove(true, -1, super.size());
		return (T)super.removeLast();
	}
	@Override
	public boolean remove(Object o) {
		int foundIndex = super.indexOf(o);
		if (foundIndex > -1)
			return updateIdxRemove(super.remove(o), -1, foundIndex);
		return false;
	}

	@Override
	public boolean equals(Object o){
		if (o.getClass() == this.getClass()) {
			return ((SmartIterator) o).getLoopedAround() == loopedAround
			    && ((SmartIterator) o).getIdx() == this.idx
			    && super.equals(o)
			;
		} else {
			return false;
		}
	}

	// hashCode: autogenerated by netbeans
	@Override
	public int hashCode() {
		int hash = 7;
		hash = 17 * hash + this.idx;
		hash = 17 * hash + this.loopedAround;
		return hash;
	}

	@Override
	public void clear() {
		init();
		super.clear();
	}

	@Override
	public boolean addAll(Collection c) {
		return updateIdx(super.addAll(c), c.size());
	}
	@Override
	public boolean addAll(int addIndex, Collection c) {
		return updateIdxAdd(super.addAll(addIndex, c), c.size(), addIndex);
	}
	@Override
	public void removeRange(int begIndex, int endIndex) {
		super.removeRange(begIndex, endIndex);
		int diff = idx - begIndex;
		if (diff > 0) {
			setIdx(idx - diff, true); // update with nofail
		}
	}

	// !! Destructive for idx and loopedAround
	@Override
	public boolean removeAll(Collection c) {
		init();
		return super.removeAll(c);
	}

	// !! Destructive for idx and loopedAround
	@Override
	public boolean retainAll(Collection c) {
		init();
		return super.retainAll(c);
	}

	@Override
	public ListIterator<T> listIterator() {
		return (ListIterator<T>)clone(); // what did you expect? x)
	}
	@Override
	public Iterator<T> iterator() {
		return (Iterator<T>)clone(); // even worse here x)
	}
	@Override
	public ListIterator<T> listIterator(int index) {
		return super.listIterator(); // et pis flemme aussi hein
	}

	// !! Destructive for idx and loopedAround
	@Override
	public boolean removeIf(Predicate<? super T> filter) {
		init();
		return super.removeIf(filter);
	}

	///// loopedAround

	public int getLoopedAround() {
		return loopedAround;
	}

	public void clearLoopedAround() {
		loopedAround = 0;
	}

//	// set the arr and the idx, return: see setIdx
//	public int setArr(T[] arr, int idx, boolean nofail) {
//		this.arr = arr;
//		int status = setIdx(idx, nofail);
//
//		if (status != 0) {
//			this.idx = 0;
//		}
//		return status;
//	}
//	// wrapper: with fail
//	public int setArr(T[] arr, int idx) {
//		return setArr(arr, idx, false);
//	}
//	// wrapper: idx=0 with fail
//	public int setArr(T[] arr) {
//		return setArr(arr, 0);
//	}

	///// idx

	public int getIdx() {
		return idx;
	}

	// fails if NOT(0 <= idx < super.size())
	// returns the error width in case of fail, negative when <0, positive when >=super.size()
	// returns 0 in case of success or nofail=true
	public int setIdx(int idx, boolean nofail) {
		if (idx < 0) {
			if (nofail)
				this.idx = 0;
			else
				return idx;
		} else if (idx >= super.size()) {
			if (nofail)
				this.idx = super.size() - 1;
			else
				return idx - super.size();
		} else {
			this.idx = idx;
		}

		return 0;
	}
	// wrapper: with fail
	public int setIdx(int idx) {
		return setIdx(idx, false);
	}
}